# „Çø„Çπ„ÇØ„Ç¢„Çø„ÉÉ„ÉÅ„É°„É≥„ÉàÊ©üËÉΩÂÆüË£Ö„Ç¨„Ç§„Éâ

„Åì„ÅÆ„Éâ„Ç≠„É•„É°„É≥„Éà„Åß„ÅØ„ÄÅ„Çø„Çπ„ÇØ„Å´Ë§áÊï∞„ÅÆ„Éï„Ç°„Ç§„É´„Çí„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ„Åß„Åç„Çã„Ç¢„Çø„ÉÉ„ÉÅ„É°„É≥„ÉàÊ©üËÉΩ„ÅÆÂÆüË£ÖÊâãÈ†Ü„ÇíË™¨Êòé„Åó„Åæ„Åô„ÄÇ

## üìã ÁõÆÊ¨°

1. [Ê¶ÇË¶Å](#Ê¶ÇË¶Å)
2. [„Ç∑„Çπ„ÉÜ„É†Ë®≠Ë®à](#„Ç∑„Çπ„ÉÜ„É†Ë®≠Ë®à)
3. [ÂÆüË£ÖÊâãÈ†Ü](#ÂÆüË£ÖÊâãÈ†Ü)
4. [„Çª„Ç≠„É•„É™„ÉÜ„Ç£ËÄÉÊÖÆ‰∫ãÈ†Ö](#„Çª„Ç≠„É•„É™„ÉÜ„Ç£ËÄÉÊÖÆ‰∫ãÈ†Ö)
5. [„ÉÜ„Çπ„ÉàÊñπÊ≥ï](#„ÉÜ„Çπ„ÉàÊñπÊ≥ï)
6. [„Éà„É©„Éñ„É´„Ç∑„É•„Éº„ÉÜ„Ç£„É≥„Ç∞](#„Éà„É©„Éñ„É´„Ç∑„É•„Éº„ÉÜ„Ç£„É≥„Ç∞)

## Ê¶ÇË¶Å

### Ê©üËÉΩË¶Å‰ª∂

- „Çø„Çπ„ÇØ„Å´Ë§áÊï∞„ÅÆ„Éï„Ç°„Ç§„É´„ÇíÊ∑ª‰ªòÂèØËÉΩ
- „Éï„Ç°„Ç§„É´„ÅÆ„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ„ÄÅ„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ„ÄÅÂâäÈô§Ê©üËÉΩ
- „Çµ„Éñ„Çπ„ÇØ„É™„Éó„Ç∑„Éß„É≥„Éó„É©„É≥„Å´Âøú„Åò„Åü„Éï„Ç°„Ç§„É´„Çµ„Ç§„Ç∫Âà∂Èôê
- „Çª„Ç≠„É•„Ç¢„Å™„Éï„Ç°„Ç§„É´„Ç¢„ÇØ„Çª„ÇπÂà∂Âæ°

### ÊäÄË°ì„Çπ„Çø„ÉÉ„ÇØ

- **„Çπ„Éà„É¨„Éº„Ç∏**: 
  - ÈñãÁô∫Áí∞Â¢É: MinIOÔºàS3‰∫íÊèõÔºâ
  - Êú¨Áï™Áí∞Â¢É: Cloudflare R2
- **„Éï„Ç°„Ç§„É´„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ**: Axum„ÅÆmultipartÊ©üËÉΩ
- **„Éá„Éº„Çø„Éô„Éº„Çπ**: PostgreSQLÔºà„É°„Çø„Éá„Éº„Çø‰øùÂ≠òÔºâ

## „Ç∑„Çπ„ÉÜ„É†Ë®≠Ë®à

### 1. „Éá„Éº„Çø„Éô„Éº„ÇπË®≠Ë®à

#### Êñ∞Ë¶è„ÉÜ„Éº„Éñ„É´: `task_attachments`

```sql
CREATE TABLE task_attachments (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    task_id UUID NOT NULL REFERENCES tasks(id) ON DELETE CASCADE,
    uploaded_by UUID NOT NULL REFERENCES users(id),
    file_name VARCHAR(255) NOT NULL,
    file_size BIGINT NOT NULL,
    mime_type VARCHAR(100) NOT NULL,
    storage_key VARCHAR(500) NOT NULL UNIQUE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- „Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ
CREATE INDEX idx_task_attachments_task_id ON task_attachments(task_id);
CREATE INDEX idx_task_attachments_uploaded_by ON task_attachments(uploaded_by);
```

### 2. APIË®≠Ë®à

#### „Ç®„É≥„Éâ„Éù„Ç§„É≥„Éà‰∏ÄË¶ß

| „É°„ÇΩ„ÉÉ„Éâ | „Éë„Çπ | Ë™¨Êòé | Ë™çË®º |
|---------|------|------|------|
| POST | `/tasks/{task_id}/attachments` | „Éï„Ç°„Ç§„É´„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ | ÂøÖË¶Å |
| GET | `/tasks/{task_id}/attachments` | „Ç¢„Çø„ÉÉ„ÉÅ„É°„É≥„Éà‰∏ÄË¶ßÂèñÂæó | ÂøÖË¶Å |
| GET | `/attachments/{attachment_id}` | „Éï„Ç°„Ç§„É´„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ | ÂøÖË¶Å |
| DELETE | `/attachments/{attachment_id}` | „Éï„Ç°„Ç§„É´ÂâäÈô§ | ÂøÖË¶Å |

#### „É™„ÇØ„Ç®„Çπ„Éà/„É¨„Çπ„Éù„É≥„Çπ‰æã

**„Éï„Ç°„Ç§„É´„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ**
```bash
POST /tasks/{task_id}/attachments
Content-Type: multipart/form-data

file: (binary)
```

**„É¨„Çπ„Éù„É≥„Çπ**
```json
{
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "task_id": "660e8400-e29b-41d4-a716-446655440000",
  "file_name": "Ë®≠Ë®àÊõ∏.pdf",
  "file_size": 1048576,
  "mime_type": "application/pdf",
  "created_at": "2024-01-01T00:00:00Z"
}
```

### 3. „Éï„Ç°„Ç§„É´„Çµ„Ç§„Ç∫Âà∂Èôê

| „Éó„É©„É≥ | ÊúÄÂ§ß„Éï„Ç°„Ç§„É´„Çµ„Ç§„Ç∫ | ÊúÄÂ§ß„Çπ„Éà„É¨„Éº„Ç∏ÂÆπÈáè |
|--------|-------------------|-------------------|
| Free | 5MB | 100MB |
| Pro | 50MB | 10GB |
| Enterprise | 500MB | ÁÑ°Âà∂Èôê |

## ÂÆüË£ÖÊâãÈ†Ü

### Step 1: ‰æùÂ≠òÈñ¢‰øÇ„ÅÆËøΩÂä†

`task-backend/Cargo.toml`„Å´‰ª•‰∏ã„ÇíËøΩÂä†:

```toml
[dependencies]
# S3‰∫íÊèõ„Çπ„Éà„É¨„Éº„Ç∏Áî®ÔºàMinIO/Cloudflare R2ÂØæÂøúÔºâ
aws-config = "1.5"
aws-sdk-s3 = "1.57"

# „Éï„Ç°„Ç§„É´„Çø„Ç§„ÉóÊ§úÂá∫
mime = "0.3"

# „Éû„É´„ÉÅ„Éë„Éº„ÉàÂá¶ÁêÜÔºàÊó¢„Å´axum„Å´Âê´„Åæ„Çå„Å¶„ÅÑ„ÇãÔºâ
axum = { version = "0.8", features = ["multipart"] }

# UUIDÁîüÊàê
uuid = { version = "1.11", features = ["v4"] }
```

**ÈáçË¶Å**: aws-sdk-s3„ÅØAWS S3 API„ÅÆÊ®ôÊ∫ñÂÆüË£Ö„Åß„ÅÇ„Çä„ÄÅMinIO„Å®Cloudflare R2„ÅÆ‰∏°Êñπ„ÅåS3 API„Å®‰∫íÊèõÊÄß„Åå„ÅÇ„Çã„Åü„ÇÅ„ÄÅ„Åì„ÅÆSDK„Åß‰∏°Êñπ„ÅÆ„Çµ„Éº„Éì„Çπ„ÇíÂà©Áî®„Åß„Åç„Åæ„Åô„ÄÇ

### Step 2: „Éû„Ç§„Ç∞„É¨„Éº„Ç∑„Éß„É≥„Éï„Ç°„Ç§„É´„ÅÆ‰ΩúÊàê

```bash
# Êñ∞„Åó„ÅÑ„Éû„Ç§„Ç∞„É¨„Éº„Ç∑„Éß„É≥„Éï„Ç°„Ç§„É´„Çí‰ΩúÊàê
cd migration
sea-orm-cli migrate generate create_task_attachments_table
```

ÁîüÊàê„Åï„Çå„Åü„Éï„Ç°„Ç§„É´„Å´‰ª•‰∏ã„ÅÆÂÜÖÂÆπ„ÇíÂÆüË£Ö:

```rust
// migration/src/mYYYYMMDD_HHMMSS_create_task_attachments_table.rs
use sea_orm_migration::{prelude::*, schema::*};

#[derive(DeriveMigrationName)]
pub struct Migration;

#[async_trait::async_trait]
impl MigrationTrait for Migration {
    async fn up(&self, manager: &SchemaManager) -> Result<(), DbErr> {
        manager
            .create_table(
                Table::create()
                    .table(TaskAttachment::Table)
                    .if_not_exists()
                    .col(uuid(TaskAttachment::Id).primary_key())
                    .col(uuid(TaskAttachment::TaskId).not_null())
                    .col(uuid(TaskAttachment::UploadedBy).not_null())
                    .col(string(TaskAttachment::FileName).not_null())
                    .col(big_integer(TaskAttachment::FileSize).not_null())
                    .col(string(TaskAttachment::MimeType).not_null())
                    .col(string(TaskAttachment::StorageKey).not_null().unique_key())
                    .col(timestamp_with_time_zone(TaskAttachment::CreatedAt).not_null())
                    .col(timestamp_with_time_zone(TaskAttachment::UpdatedAt).not_null())
                    .foreign_key(
                        ForeignKey::create()
                            .name("fk_task_attachment_task")
                            .from(TaskAttachment::Table, TaskAttachment::TaskId)
                            .to(Task::Table, Task::Id)
                            .on_delete(ForeignKeyAction::Cascade),
                    )
                    .foreign_key(
                        ForeignKey::create()
                            .name("fk_task_attachment_user")
                            .from(TaskAttachment::Table, TaskAttachment::UploadedBy)
                            .to(User::Table, User::Id),
                    )
                    .to_owned(),
            )
            .await?;

        // „Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„ÅÆ‰ΩúÊàê
        manager
            .create_index(
                Index::create()
                    .name("idx_task_attachments_task_id")
                    .table(TaskAttachment::Table)
                    .col(TaskAttachment::TaskId)
                    .to_owned(),
            )
            .await?;

        Ok(())
    }

    async fn down(&self, manager: &SchemaManager) -> Result<(), DbErr> {
        manager
            .drop_table(Table::drop().table(TaskAttachment::Table).to_owned())
            .await
    }
}

#[derive(DeriveIden)]
enum TaskAttachment {
    Table,
    Id,
    TaskId,
    UploadedBy,
    FileName,
    FileSize,
    MimeType,
    StorageKey,
    CreatedAt,
    UpdatedAt,
}

#[derive(DeriveIden)]
enum Task {
    Table,
    Id,
}

#[derive(DeriveIden)]
enum User {
    Table,
    Id,
}
```

### Step 3: „Éâ„É°„Ç§„É≥„É¢„Éá„É´„ÅÆ‰ΩúÊàê

```rust
// task-backend/src/domain/task_attachment_model.rs
use chrono::{DateTime, Utc};
use sea_orm::entity::prelude::*;
use serde::{Deserialize, Serialize};

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Serialize, Deserialize)]
#[sea_orm(table_name = "task_attachments")]
pub struct Model {
    #[sea_orm(primary_key, auto_increment = false)]
    pub id: Uuid,
    pub task_id: Uuid,
    pub uploaded_by: Uuid,
    pub file_name: String,
    pub file_size: i64,
    pub mime_type: String,
    pub storage_key: String,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(
        belongs_to = "super::task_model::Entity",
        from = "Column::TaskId",
        to = "super::task_model::Column::Id"
    )]
    Task,
    
    #[sea_orm(
        belongs_to = "super::user_model::Entity",
        from = "Column::UploadedBy",
        to = "super::user_model::Column::Id"
    )]
    User,
}

impl Related<super::task_model::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::Task.def()
    }
}

impl Related<super::user_model::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::User.def()
    }
}

impl ActiveModelBehavior for ActiveModel {}
```

### Step 4: „Çπ„Éà„É¨„Éº„Ç∏„Çµ„Éº„Éì„Çπ„ÅÆÂÆüË£Ö

```rust
// task-backend/src/service/storage_service.rs
use async_trait::async_trait;
use aws_sdk_s3::{Client, Config};
use aws_sdk_s3::config::{Credentials, Region};
use aws_sdk_s3::primitives::ByteStream;
use std::error::Error;
use uuid::Uuid;

#[async_trait]
pub trait StorageService: Send + Sync {
    async fn upload(
        &self,
        file_data: Vec<u8>,
        content_type: &str,
    ) -> Result<String, Box<dyn Error>>;
    
    async fn download(&self, key: &str) -> Result<Vec<u8>, Box<dyn Error>>;
    
    async fn delete(&self, key: &str) -> Result<(), Box<dyn Error>>;
}

pub struct S3StorageService {
    client: Client,
    bucket: String,
}

impl S3StorageService {
    pub async fn new(config: &StorageConfig) -> Result<Self, Box<dyn Error>> {
        let credentials = Credentials::new(
            &config.access_key,
            &config.secret_key,
            None,
            None,
            "storage",
        );

        let s3_config = Config::builder()
            .region(Region::new(config.region.clone()))
            .endpoint_url(&config.endpoint)
            .credentials_provider(credentials)
            .force_path_style(true) // MinIOÁî®ÔºàCloudflare R2„ÇÇÂØæÂøúÔºâ
            .build();

        let client = Client::from_conf(s3_config);

        Ok(Self {
            client,
            bucket: config.bucket.clone(),
        })
    }
}

#[async_trait]
impl StorageService for S3StorageService {
    async fn upload(
        &self,
        file_data: Vec<u8>,
        content_type: &str,
    ) -> Result<String, Box<dyn Error>> {
        let key = format!("attachments/{}", Uuid::new_v4());
        
        self.client
            .put_object()
            .bucket(&self.bucket)
            .key(&key)
            .body(ByteStream::from(file_data))
            .content_type(content_type)
            .send()
            .await?;

        Ok(key)
    }

    async fn download(&self, key: &str) -> Result<Vec<u8>, Box<dyn Error>> {
        let response = self.client
            .get_object()
            .bucket(&self.bucket)
            .key(key)
            .send()
            .await?;

        let data = response.body.collect().await?;
        Ok(data.to_vec())
    }

    async fn delete(&self, key: &str) -> Result<(), Box<dyn Error>> {
        self.client
            .delete_object()
            .bucket(&self.bucket)
            .key(key)
            .send()
            .await?;

        Ok(())
    }
}

#[derive(Clone)]
pub struct StorageConfig {
    pub endpoint: String,
    pub bucket: String,
    pub region: String,
    pub access_key: String,
    pub secret_key: String,
}
```

### Step 5: „Ç¢„Çø„ÉÉ„ÉÅ„É°„É≥„Éà„Çµ„Éº„Éì„Çπ„ÅÆÂÆüË£Ö

```rust
// task-backend/src/service/attachment_service.rs
use crate::domain::task_attachment_model::{self, Entity as TaskAttachment};
use crate::repository::attachment_repository::AttachmentRepository;
use crate::service::storage_service::StorageService;
use crate::error::AppError;
use sea_orm::DatabaseConnection;
use std::sync::Arc;
use uuid::Uuid;

pub struct AttachmentService {
    db: Arc<DatabaseConnection>,
    storage: Arc<dyn StorageService>,
    repository: AttachmentRepository,
}

impl AttachmentService {
    pub fn new(
        db: Arc<DatabaseConnection>,
        storage: Arc<dyn StorageService>,
    ) -> Self {
        Self {
            db: db.clone(),
            storage,
            repository: AttachmentRepository::new(db),
        }
    }

    pub async fn upload_attachment(
        &self,
        task_id: Uuid,
        user_id: Uuid,
        file_name: String,
        file_data: Vec<u8>,
        mime_type: String,
    ) -> Result<task_attachment_model::Model, AppError> {
        // „Éï„Ç°„Ç§„É´„Çµ„Ç§„Ç∫„ÉÅ„Çß„ÉÉ„ÇØ
        let file_size = file_data.len() as i64;
        self.validate_file_size(user_id, file_size).await?;

        // „Çπ„Éà„É¨„Éº„Ç∏„Å´„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ
        let storage_key = self.storage
            .upload(file_data, &mime_type)
            .await
            .map_err(|e| AppError::InternalServerError(e.to_string()))?;

        // „É°„Çø„Éá„Éº„Çø„ÇíDB„Å´‰øùÂ≠ò
        let attachment = self.repository
            .create(CreateAttachmentDto {
                task_id,
                uploaded_by: user_id,
                file_name,
                file_size,
                mime_type,
                storage_key,
            })
            .await?;

        Ok(attachment)
    }

    pub async fn download_attachment(
        &self,
        attachment_id: Uuid,
        user_id: Uuid,
    ) -> Result<(Vec<u8>, String, String), AppError> {
        // „Ç¢„Çø„ÉÉ„ÉÅ„É°„É≥„ÉàÊÉÖÂ†±„ÇíÂèñÂæó
        let attachment = self.repository
            .find_by_id(attachment_id)
            .await?
            .ok_or(AppError::NotFound("Attachment not found".to_string()))?;

        // „Ç¢„ÇØ„Çª„ÇπÊ®©Èôê„ÉÅ„Çß„ÉÉ„ÇØ
        self.check_access_permission(user_id, attachment.task_id).await?;

        // „Çπ„Éà„É¨„Éº„Ç∏„Åã„Çâ„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ
        let file_data = self.storage
            .download(&attachment.storage_key)
            .await
            .map_err(|e| AppError::InternalServerError(e.to_string()))?;

        Ok((file_data, attachment.file_name, attachment.mime_type))
    }

    pub async fn delete_attachment(
        &self,
        attachment_id: Uuid,
        user_id: Uuid,
    ) -> Result<(), AppError> {
        // „Ç¢„Çø„ÉÉ„ÉÅ„É°„É≥„ÉàÊÉÖÂ†±„ÇíÂèñÂæó
        let attachment = self.repository
            .find_by_id(attachment_id)
            .await?
            .ok_or(AppError::NotFound("Attachment not found".to_string()))?;

        // „Ç¢„ÇØ„Çª„ÇπÊ®©Èôê„ÉÅ„Çß„ÉÉ„ÇØ
        self.check_delete_permission(user_id, attachment.task_id).await?;

        // „Çπ„Éà„É¨„Éº„Ç∏„Åã„ÇâÂâäÈô§
        self.storage
            .delete(&attachment.storage_key)
            .await
            .map_err(|e| AppError::InternalServerError(e.to_string()))?;

        // DB„Åã„ÇâÂâäÈô§
        self.repository.delete(attachment_id).await?;

        Ok(())
    }

    async fn validate_file_size(
        &self,
        user_id: Uuid,
        file_size: i64,
    ) -> Result<(), AppError> {
        // „É¶„Éº„Ç∂„Éº„ÅÆ„Çµ„Éñ„Çπ„ÇØ„É™„Éó„Ç∑„Éß„É≥„Éó„É©„É≥„ÇíÂèñÂæó
        let max_size = self.get_max_file_size_for_user(user_id).await?;
        
        if file_size > max_size {
            return Err(AppError::BadRequest(
                format!("File size exceeds limit of {} bytes", max_size)
            ));
        }

        Ok(())
    }

    async fn get_max_file_size_for_user(&self, user_id: Uuid) -> Result<i64, AppError> {
        // TODO: „É¶„Éº„Ç∂„Éº„ÅÆ„Çµ„Éñ„Çπ„ÇØ„É™„Éó„Ç∑„Éß„É≥„Éó„É©„É≥„Å´Âü∫„Å•„ÅÑ„Å¶Âà∂Èôê„ÇíËøî„Åô
        // ‰ªÆÂÆüË£Ö
        Ok(5 * 1024 * 1024) // 5MB
    }

    async fn check_access_permission(
        &self,
        user_id: Uuid,
        task_id: Uuid,
    ) -> Result<(), AppError> {
        // TODO: „Çø„Çπ„ÇØ„Å∏„ÅÆ„Ç¢„ÇØ„Çª„ÇπÊ®©Èôê„Çí„ÉÅ„Çß„ÉÉ„ÇØ
        Ok(())
    }

    async fn check_delete_permission(
        &self,
        user_id: Uuid,
        task_id: Uuid,
    ) -> Result<(), AppError> {
        // TODO: ÂâäÈô§Ê®©Èôê„Çí„ÉÅ„Çß„ÉÉ„ÇØÔºà„Ç¢„ÉÉ„Éó„É≠„Éº„ÉâËÄÖ„Åæ„Åü„ÅØ„Çø„Çπ„ÇØÊâÄÊúâËÄÖÔºâ
        Ok(())
    }
}

#[derive(Debug)]
pub struct CreateAttachmentDto {
    pub task_id: Uuid,
    pub uploaded_by: Uuid,
    pub file_name: String,
    pub file_size: i64,
    pub mime_type: String,
    pub storage_key: String,
}
```

### Step 6: API„Éè„É≥„Éâ„É©„Éº„ÅÆÂÆüË£Ö

```rust
// task-backend/src/api/handlers/attachment_handler.rs
use axum::{
    extract::{Multipart, Path, State},
    http::StatusCode,
    response::{IntoResponse, Response},
    Json,
};
use crate::api::dto::attachment_dto::{AttachmentResponse, AttachmentListResponse};
use crate::auth::AuthenticatedUser;
use crate::service::attachment_service::AttachmentService;
use std::sync::Arc;
use uuid::Uuid;

pub async fn upload_attachment(
    State(service): State<Arc<AttachmentService>>,
    Path(task_id): Path<Uuid>,
    user: AuthenticatedUser,
    mut multipart: Multipart,
) -> Result<Json<AttachmentResponse>, AppError> {
    // „Éû„É´„ÉÅ„Éë„Éº„Éà„Éá„Éº„Çø„ÇíÂá¶ÁêÜ
    while let Some(field) = multipart.next_field().await? {
        let name = field.name().unwrap_or("").to_string();
        
        if name == "file" {
            let file_name = field.file_name()
                .ok_or(AppError::BadRequest("File name is required".to_string()))?
                .to_string();
            
            let content_type = field.content_type()
                .unwrap_or("application/octet-stream")
                .to_string();
            
            let data = field.bytes().await?;
            
            // „Ç¢„ÉÉ„Éó„É≠„Éº„ÉâÂá¶ÁêÜ
            let attachment = service
                .upload_attachment(
                    task_id,
                    user.id,
                    file_name,
                    data.to_vec(),
                    content_type,
                )
                .await?;
            
            return Ok(Json(AttachmentResponse::from(attachment)));
        }
    }
    
    Err(AppError::BadRequest("No file provided".to_string()))
}

pub async fn list_attachments(
    State(service): State<Arc<AttachmentService>>,
    Path(task_id): Path<Uuid>,
    user: AuthenticatedUser,
) -> Result<Json<AttachmentListResponse>, AppError> {
    let attachments = service.list_by_task(task_id, user.id).await?;
    
    Ok(Json(AttachmentListResponse {
        attachments: attachments.into_iter().map(AttachmentResponse::from).collect(),
    }))
}

pub async fn download_attachment(
    State(service): State<Arc<AttachmentService>>,
    Path(attachment_id): Path<Uuid>,
    user: AuthenticatedUser,
) -> Result<Response, AppError> {
    let (data, file_name, mime_type) = service
        .download_attachment(attachment_id, user.id)
        .await?;
    
    // „Éï„Ç°„Ç§„É´„É¨„Çπ„Éù„É≥„Çπ„ÇíÊßãÁØâ
    Ok((
        StatusCode::OK,
        [
            ("Content-Type", mime_type),
            ("Content-Disposition", format!("attachment; filename=\"{}\"", file_name)),
        ],
        data,
    ).into_response())
}

pub async fn delete_attachment(
    State(service): State<Arc<AttachmentService>>,
    Path(attachment_id): Path<Uuid>,
    user: AuthenticatedUser,
) -> Result<StatusCode, AppError> {
    service.delete_attachment(attachment_id, user.id).await?;
    
    Ok(StatusCode::NO_CONTENT)
}
```

### Step 7: „É´„Éº„ÉÜ„Ç£„É≥„Ç∞„ÅÆË®≠ÂÆö

```rust
// task-backend/src/api/routes.rs „Å´ËøΩÂä†
use crate::api::handlers::attachment_handler;

pub fn attachment_routes() -> Router<Arc<AppState>> {
    Router::new()
        .route("/tasks/:task_id/attachments", post(attachment_handler::upload_attachment))
        .route("/tasks/:task_id/attachments", get(attachment_handler::list_attachments))
        .route("/attachments/:attachment_id", get(attachment_handler::download_attachment))
        .route("/attachments/:attachment_id", delete(attachment_handler::delete_attachment))
}

// main.rs„Åß„É´„Éº„Éà„ÇíÁôªÈå≤
app = app.nest("/api", attachment_routes());
```

### Step 8: Áí∞Â¢ÉË®≠ÂÆö

`.env`„Éï„Ç°„Ç§„É´„Å´‰ª•‰∏ã„ÇíËøΩÂä†:

```env
# ÈñãÁô∫Áí∞Â¢ÉÔºàMinIOÔºâ
STORAGE_ENDPOINT=http://localhost:9000
STORAGE_BUCKET=task-attachments
STORAGE_REGION=us-east-1
STORAGE_ACCESS_KEY=minioadmin
STORAGE_SECRET_KEY=minioadmin

# Êú¨Áï™Áí∞Â¢ÉÔºàCloudflare R2Ôºâ
# STORAGE_ENDPOINT=https://YOUR_ACCOUNT_ID.r2.cloudflarestorage.com
# STORAGE_BUCKET=task-attachments
# STORAGE_REGION=auto
# STORAGE_ACCESS_KEY=your_r2_access_key
# STORAGE_SECRET_KEY=your_r2_secret_key
```

## „Çª„Ç≠„É•„É™„ÉÜ„Ç£ËÄÉÊÖÆ‰∫ãÈ†Ö

### 1. „Éï„Ç°„Ç§„É´„Çø„Ç§„Éó„ÅÆÂà∂Èôê

```rust
// Ë®±ÂèØ„Åô„ÇãMIME„Çø„Ç§„Éó„ÅÆ„Éõ„ÉØ„Ç§„Éà„É™„Çπ„Éà
const ALLOWED_MIME_TYPES: &[&str] = &[
    "image/jpeg",
    "image/png",
    "image/gif",
    "image/webp",
    "application/pdf",
    "application/msword",
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
    "application/vnd.ms-excel",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    "text/plain",
    "text/csv",
];

fn validate_mime_type(mime_type: &str) -> Result<(), AppError> {
    if !ALLOWED_MIME_TYPES.contains(&mime_type) {
        return Err(AppError::BadRequest("File type not allowed".to_string()));
    }
    Ok(())
}
```

### 2. „Éï„Ç°„Ç§„É´Âêç„ÅÆ„Çµ„Éã„Çø„Ç§„Çº„Éº„Ç∑„Éß„É≥

```rust
fn sanitize_filename(filename: &str) -> String {
    // Âç±Èô∫„Å™ÊñáÂ≠ó„ÇíÈô§Âéª
    filename
        .chars()
        .filter(|c| c.is_alphanumeric() || *c == '.' || *c == '-' || *c == '_' || *c == ' ')
        .collect::<String>()
        .trim()
        .to_string()
}
```

### 3. „Ç¶„Ç§„É´„Çπ„Çπ„Ç≠„É£„É≥Ôºà„Ç™„Éó„Ç∑„Éß„É≥Ôºâ

```rust
// ClamAV„Å™„Å©„ÅÆ„Ç¶„Ç§„É´„Çπ„Çπ„Ç≠„É£„Éä„Éº„Å®„ÅÆÁµ±Âêà
#[async_trait]
trait VirusScanService {
    async fn scan(&self, data: &[u8]) -> Result<bool, Box<dyn Error>>;
}
```

### 4. „Ç¢„ÇØ„Çª„ÇπÂà∂Âæ°

- „Çø„Çπ„ÇØ„ÅÆÈñ≤Ë¶ßÊ®©Èôê„ÇíÊåÅ„Å§„É¶„Éº„Ç∂„Éº„ÅÆ„Åø„Ç¢„Çø„ÉÉ„ÉÅ„É°„É≥„Éà„Å´„Ç¢„ÇØ„Çª„ÇπÂèØËÉΩ
- „Ç¢„ÉÉ„Éó„É≠„Éº„ÉâËÄÖ„Åæ„Åü„ÅØ„Çø„Çπ„ÇØÊâÄÊúâËÄÖ„ÅÆ„ÅøÂâäÈô§ÂèØËÉΩ
- Áõ¥Êé•URL„Ç¢„ÇØ„Çª„Çπ„ÇíÈò≤„Åê„Åü„ÇÅ„ÄÅÁΩ≤Âêç‰ªò„ÅçURL„Åæ„Åü„ÅØË™çË®º‰ªò„Åç„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ

## „ÉÜ„Çπ„ÉàÊñπÊ≥ï

### 1. Áµ±Âêà„ÉÜ„Çπ„Éà„ÅÆ‰æã

```rust
// task-backend/tests/integration/attachment_tests.rs
#[tokio::test]
async fn test_upload_attachment_success() {
    let (app, _schema, _db) = setup_full_app().await;
    let user = create_and_authenticate_user(&app).await;
    let task = create_test_task(&app, &user).await;
    
    // „Éï„Ç°„Ç§„É´„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ
    let file_data = b"test file content";
    let response = app.oneshot(
        Request::builder()
            .method("POST")
            .uri(&format!("/api/tasks/{}/attachments", task.id))
            .header("Authorization", &format!("Bearer {}", user.token))
            .header("Content-Type", "multipart/form-data; boundary=----boundary")
            .body(Body::from(
                format!(
                    "------boundary\r\n\
                    Content-Disposition: form-data; name=\"file\"; filename=\"test.txt\"\r\n\
                    Content-Type: text/plain\r\n\r\n\
                    {}\r\n\
                    ------boundary--\r\n",
                    String::from_utf8_lossy(file_data)
                )
            ))
            .unwrap()
    ).await.unwrap();
    
    assert_eq!(response.status(), StatusCode::OK);
}

#[tokio::test]
async fn test_file_size_limit_exceeded() {
    // „Éï„Ç°„Ç§„É´„Çµ„Ç§„Ç∫Âà∂Èôê„ÅÆ„ÉÜ„Çπ„Éà
}

#[tokio::test]
async fn test_unauthorized_access() {
    // Ê®©Èôê„ÅÆ„Å™„ÅÑ„É¶„Éº„Ç∂„Éº„ÅÆ„Ç¢„ÇØ„Çª„Çπ„ÉÜ„Çπ„Éà
}
```

### 2. ÊâãÂãï„ÉÜ„Çπ„ÉàÁî®„ÅÆcURL„Ç≥„Éû„É≥„Éâ

```bash
# „Éï„Ç°„Ç§„É´„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ
curl -X POST \
  http://localhost:3000/api/tasks/{task_id}/attachments \
  -H "Authorization: Bearer YOUR_TOKEN" \
  -F "file=@/path/to/file.pdf"

# „Ç¢„Çø„ÉÉ„ÉÅ„É°„É≥„Éà‰∏ÄË¶ßÂèñÂæó
curl -X GET \
  http://localhost:3000/api/tasks/{task_id}/attachments \
  -H "Authorization: Bearer YOUR_TOKEN"

# „Éï„Ç°„Ç§„É´„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ
curl -X GET \
  http://localhost:3000/api/attachments/{attachment_id} \
  -H "Authorization: Bearer YOUR_TOKEN" \
  -o downloaded_file.pdf

# „Éï„Ç°„Ç§„É´ÂâäÈô§
curl -X DELETE \
  http://localhost:3000/api/attachments/{attachment_id} \
  -H "Authorization: Bearer YOUR_TOKEN"
```

## SDK‰∫íÊèõÊÄßÊÉÖÂ†±

### MinIO„Å®„ÅÆ‰∫íÊèõÊÄß
- **ÂÆåÂÖ®ÂØæÂøú**: MinIO„ÅØÊúÄ„ÇÇÂ∫É„Åè„ÉÜ„Çπ„Éà„Åï„Çå„ÅüS3‰∫íÊèõ„Çπ„Éà„É¨„Éº„Ç∏
- **Ë®≠ÂÆöË¶Å‰ª∂**: `force_path_style(true)`„ÇíË®≠ÂÆöÔºà„Éë„Çπ„Çπ„Çø„Ç§„É´URLÂøÖÈ†àÔºâ
- **Ë™çË®º**: AWS Signature Version 4„Çí„Çµ„Éù„Éº„Éà

### Cloudflare R2„Å®„ÅÆ‰∫íÊèõÊÄß
- **ÂØæÂøúÁ¢∫Ë™çÊ∏à„Åø**: aws-sdk-s3„Åß„ÅÆÂà©Áî®„ÅåÂÖ¨Âºè„Å´„Çµ„Éù„Éº„Éà
- **Ë®≠ÂÆöË¶Å‰ª∂**:
  - „É™„Éº„Ç∏„Éß„É≥„ÅØ`auto`„Å´Ë®≠ÂÆö
  - „ÉÅ„Çß„ÉÉ„ÇØ„Çµ„É†Èñ¢ÈÄ£„ÅÆ„Ç®„É©„Éº„ÅåÂá∫„ÇãÂ†¥Âêà„ÅØ„ÄÅSDK„Éê„Éº„Ç∏„Éß„É≥„ÅÆË™øÊï¥„ÅåÂøÖË¶Å„Å™Â†¥Âêà„ÅÇ„Çä
  - „Éê„ÉÉ„ÉÅÂâäÈô§„ÅØ700‰ª∂‰ª•‰∏ã„Å´Âà∂Èôê

### ÂÖ±ÈÄö„ÅÆÊ≥®ÊÑèÁÇπ
- ‰∏°„Çµ„Éº„Éì„Çπ„Å®„ÇÇS3 API„ÅÆ‰∏ªË¶ÅÊ©üËÉΩ„Çí„Çµ„Éù„Éº„Éà
- IAM API„ÅØÈùûÂØæÂøúÔºàMinIO„ÄÅR2ÂÖ±ÈÄöÔºâ
- „Ç®„É≥„Éâ„Éù„Ç§„É≥„ÉàURL„ÅÆÊåáÂÆö„ÅåÂøÖÈ†à

## „Éà„É©„Éñ„É´„Ç∑„É•„Éº„ÉÜ„Ç£„É≥„Ç∞

### „Çà„Åè„ÅÇ„ÇãÂïèÈ°å„Å®Ëß£Ê±∫ÊñπÊ≥ï

#### 1. MinIO„Å∏„ÅÆÊé•Á∂ö„Ç®„É©„Éº

**ÁóáÁä∂**: `Connection refused`„Ç®„É©„Éº

**Ëß£Ê±∫ÊñπÊ≥ï**:
```bash
# MinIO„ÇíDocker„ÅßËµ∑Âãï
docker run -d \
  -p 9000:9000 \
  -p 9001:9001 \
  --name minio \
  -e MINIO_ROOT_USER=minioadmin \
  -e MINIO_ROOT_PASSWORD=minioadmin \
  minio/minio server /data --console-address ":9001"

# „Éê„Ç±„ÉÉ„Éà„Çí‰ΩúÊàê
mc alias set local http://localhost:9000 minioadmin minioadmin
mc mb local/task-attachments
```

#### 2. „Éï„Ç°„Ç§„É´„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ„Åå413„Ç®„É©„Éº

**ÁóáÁä∂**: `Payload Too Large`„Ç®„É©„Éº

**Ëß£Ê±∫ÊñπÊ≥ï**:
```rust
// main.rs„Åß„Éú„Éá„Ç£„Çµ„Ç§„Ç∫Âà∂Èôê„ÇíË®≠ÂÆö
use axum::extract::DefaultBodyLimit;

let app = Router::new()
    .layer(DefaultBodyLimit::max(100 * 1024 * 1024)); // 100MB
```

#### 3. CORS „Ç®„É©„Éº

**ÁóáÁä∂**: „Éñ„É©„Ç¶„Ç∂„Åã„Çâ„ÅÆ„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ„ÅåÂ§±Êïó

**Ëß£Ê±∫ÊñπÊ≥ï**:
```rust
use tower_http::cors::{CorsLayer, Any};

let cors = CorsLayer::new()
    .allow_methods(Any)
    .allow_origin(Any)
    .allow_headers(Any);

let app = app.layer(cors);
```

### „Éá„Éê„ÉÉ„Ç∞Tips

1. **„É≠„Ç∞„É¨„Éô„É´„Çí‰∏ä„Åí„Çã**
   ```bash
   RUST_LOG=debug cargo run
   ```

2. **MinIOÁÆ°ÁêÜÁîªÈù¢„ÅßÁ¢∫Ë™ç**
   - http://localhost:9001 „Å´„Ç¢„ÇØ„Çª„Çπ
   - „É¶„Éº„Ç∂„ÉºÂêç: minioadmin
   - „Éë„Çπ„ÉØ„Éº„Éâ: minioadmin

3. **„Éá„Éº„Çø„Éô„Éº„Çπ„ÅÆÁ¢∫Ë™ç**
   ```sql
   SELECT * FROM task_attachments WHERE task_id = 'YOUR_TASK_ID';
   ```

## Ê¨°„ÅÆ„Çπ„ÉÜ„ÉÉ„Éó

### Ê©üËÉΩÊã°Âºµ„ÅÆ„Ç¢„Ç§„Éá„Ç¢

1. **„Çµ„É†„Éç„Ç§„É´ÁîüÊàê**
   - ÁîªÂÉè„Éï„Ç°„Ç§„É´„ÅÆËá™Âãï„Çµ„É†„Éç„Ç§„É´ÁîüÊàê
   - PDF„ÅÆ„Éó„É¨„Éì„É•„ÉºÁîªÂÉèÁîüÊàê

2. **„Éê„Éº„Ç∏„Éß„É≥ÁÆ°ÁêÜ**
   - ÂêåÂêç„Éï„Ç°„Ç§„É´„ÅÆ„Éê„Éº„Ç∏„Éß„É≥ÁÆ°ÁêÜ
   - Â§âÊõ¥Â±•Ê≠¥„ÅÆËøΩË∑°

3. **ÂÖ±ÊúâÊ©üËÉΩ**
   - Â§ñÈÉ®ÂÖ±ÊúâÁî®„ÅÆÊúüÈôê‰ªò„ÅçURLÁîüÊàê
   - „Éë„Çπ„ÉØ„Éº„Éâ‰øùË≠∑

4. **Ê§úÁ¥¢Ê©üËÉΩ**
   - „Éï„Ç°„Ç§„É´Âêç„Åß„ÅÆÊ§úÁ¥¢
   - „Éï„Ç°„Ç§„É´ÂÜÖÂÆπ„ÅÆÂÖ®ÊñáÊ§úÁ¥¢ÔºàElasticSearchÈÄ£Êê∫Ôºâ

5. **ÂúßÁ∏Æ„ÉªÂ§âÊèõ**
   - Ëá™ÂãïÂúßÁ∏Æ„Å´„Çà„Çã„Çπ„Éà„É¨„Éº„Ç∏ÁØÄÁ¥Ñ
   - „Éï„Ç°„Ç§„É´ÂΩ¢Âºè„ÅÆÂ§âÊèõÊ©üËÉΩ

„Åì„Çå„Åß„ÄÅ„Çø„Çπ„ÇØ„Ç¢„Çø„ÉÉ„ÉÅ„É°„É≥„ÉàÊ©üËÉΩ„ÅÆÂü∫Êú¨ÁöÑ„Å™ÂÆüË£Ö„ÅåÂÆå‰∫Ü„Åß„Åô„ÄÇÂøÖË¶Å„Å´Âøú„Åò„Å¶Ê©üËÉΩ„ÇíÊã°Âºµ„Åó„Å¶„ÅÑ„Å£„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ